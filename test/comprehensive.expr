letrec (
  putln = lambda (value) { (.put value "\n") }
) {
  [
    # integer literals
    (putln -0)
    (putln +1)
    # string literals and comments
    (putln "0") ## message 0
    (putln "1")
    (putln "0\n1")
    (putln "0
1")
    # variables
    letrec (x = 0 Y = 1) {
      [
        (putln x)
        (putln Y)
      ]
    }
    # letrec
    letrec (
      f = lambda (n) {
        if (.== n 0) then (.void)
        else [(putln 0) (g (.- n 1))]
      }
      g = lambda (n) {
        if (.== n 0) then (.void)
        else [(putln 1) (f (.- n 1))]
      }
    ) {
      (f 6)
    }
    # if
    if 0 then (putln "1") else (putln "0")
    if -1 then (putln "1") else (putln "0")
    # function call
    (putln (lambda (x) { (.+ x 1 0) } -1))
    # intrinsic call
    (putln (.*))
    # sequence
    (putln [1 0])
    (putln [0 1])
    [(putln 0) (putln 1)]
    # lex query
    (putln @y letrec (x = 1) { lambda () { (.void) } })
    (putln @x letrec (x = 1) { lambda () { (.void) } })
    # dyn query
    letrec (queryY = lambda () { (putln @Y) }) {
      [
        (lambda (Y) { (queryY) } 0)
        (lambda (Y) { [(queryY) 1] } 0)
      ]
    }
    # var access
    letrec (f = letrec (v = 0) { lambda () { (.void) } }) {
      (putln &v f)
    }
    (putln 1)
  ]
}
